import net from 'net';
import { ProtocolReader } from './protocol/protocol-reader';
import { Subject, Observable, take, of, delay, filter, interval } from 'rxjs';
import { HorseMessage } from './protocol/horse-message';
import { ProtocolWriter } from './protocol/protocol-writer';
import { MessageHeader } from './protocol/message-header';
import { HorseResult } from './protocol/horse-result';
import { HorseResultCode } from './protocol/horse-result-code';
import { PredefinedMessages } from './protocol/predefined-messages';
import { MessageType } from './protocol/message-type';
import { KnownContentTypes } from './protocol/known-content-types';
import { HorseHeaders } from './protocol/horse-headers';
import { CacheOperator } from './operators/cache-operator';
import { QueueOperator } from './operators/queue-operator';
import { ChannelOperator } from './operators/channel-operator';
import { DirectOperator } from './operators/direct-operator';
import { EventOperator } from './operators/event-operator';
import { RouterOperator } from './operators/router-operator';
import { IHorseClient } from './ihorse-client';
import { HorseClientStatus } from './horse-client-status';
import { NodeType, RemoteHost } from './remote-host';

let os = require("os");

interface MessageObserver {
    id: string;
    released: boolean;
    subject: Subject<HorseResult>;
}

export class HorseClient implements IHorseClient {

    private _socket: net.Socket | undefined;
    private _writer: ProtocolWriter;
    private _reader: ProtocolReader;
    private _observers: Map<string, MessageObserver> = new Map<string, MessageObserver>();
    private _lastMessageDate: number;
    private _protocolMessageReceived: boolean = false;
    private _autoReconnectDisabled: boolean = false;
    private _currentHostIndex: number = -1;

    /** Acknowledge or response message timeout in milliseconds. Default value is 15000. */
    messageTimeout: number = 15000;

    /** Interval in milliseconds for PING message how often will be sent */
    pingInterval: number = 15000;

    /** If true, ack message is sent right after queue message is received. Default value is false. */
    autoAcknowledge: boolean = false;

    /** Unique client Id. Max 255 characters. Auto generated by default. */
    clientId: string = 'node';

    /** Client Name */
    clientName: string;

    /** Client Type */
    clientType: string = 'NodeClient';

    /** Client token for authentication if required */
    clientToken: string;

    /** If true, client reconnects to the server if not disconnected manually (by calling disconnect function) */
    autoReconnect: boolean = true;

    /** Delay in milliseconds before reconnect. Default value is 2500. */
    autoReconnectDelay: number = 2500;

    /** Additional properties. These values are send with first message when connected. You can add properties for recognizing your client on server side. */
    properties: MessageHeader[] = [];

    /** Server host names */
    hosts: RemoteHost[] = [];

    /** Currently connected remote host */
    host: RemoteHost = null;

    /** Connection status */
    get status(): HorseClientStatus { return this._status; }
    private _status: HorseClientStatus = HorseClientStatus.Disconnected;

    /** Cache operator */
    get cache(): CacheOperator { return this._cache; }
    private _cache: CacheOperator;

    /** Channel operator */
    get channel(): ChannelOperator { return this._channel; }
    private _channel: ChannelOperator;

    /** Direct messaging operator */
    get direct(): DirectOperator { return this._direct; }
    private _direct: DirectOperator;

    /** Event operator */
    get event(): EventOperator { return this._event; }
    private _event: EventOperator;

    /** Queue messaging operator */
    get queue(): QueueOperator { return this._queue; }
    private _queue: QueueOperator;

    /** Router operator */
    get router(): RouterOperator { return this._router; }
    private _router: RouterOperator;

    /** Triggered when a message is received */
    private _onmessage: Subject<HorseMessage> = new Subject<HorseMessage>();
    get onmessage(): Observable<HorseMessage> { return this._onmessage; }

    /** Triggered when a log is created */
    private _onlog: Subject<string> = new Subject<string>();
    get onlog(): Observable<string> { return this._onlog; }

    /** Triggered when client connects to the remote host */
    private _onconnected: Subject<IHorseClient> = new Subject<IHorseClient>();
    get onconnected(): Observable<IHorseClient> { return this._onconnected; }

    /** Triggered when client disconnects from the remote host */
    private _ondisconnected: Subject<IHorseClient> = new Subject<IHorseClient>();
    get ondisconnected(): Observable<IHorseClient> { return this._ondisconnected; }

    constructor() {
        this._cache = new CacheOperator(this);
        this._channel = new ChannelOperator(this);
        this._direct = new DirectOperator(this);
        this._event = new EventOperator(this);
        this._queue = new QueueOperator(this);
        this._router = new RouterOperator(this);
        this._writer = new ProtocolWriter();
        this._reader = new ProtocolReader();
        this._lastMessageDate = new Date().getTime();

        this.clientId = this.generateUniqueId();
        this.clientName = os.hostname();

        this._reader.onmessage
            .subscribe(msg => {
                if (msg.type != MessageType.Ping && msg.type != MessageType.Pong && msg.type != MessageType.Terminate) {
                    this._onmessage.next(msg);
                }

                this.processReceivedMessage(msg);
            });

        interval(1000)
            .pipe(filter(() => {
                if (!this._socket || this._socket.connecting || this._socket.closed) {
                    return false;
                }

                let now = new Date().getTime();
                let diff = now - this._lastMessageDate;
                return diff > this.pingInterval;
            }))
            .subscribe(() => {
                this._lastMessageDate = new Date().getTime();
                this._socket.write(PredefinedMessages.getPingBuffer());
            });
    }

    generateUniqueId(): string {
        var d = new Date().getTime();
        var d2 = ((typeof performance !== 'undefined') && performance.now && (performance.now() * 1000)) || 0;
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16;
            if (d > 0) {
                r = (d + r) % 16 | 0;
                d = Math.floor(d / 16);
            } else {
                r = (d2 + r) % 16 | 0;
                d2 = Math.floor(d2 / 16);
            }
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        }).replace(/-/g, '');
    }

    /** Adds new remote host. Hostname should like "horse://localhost:12345" */
    addRemoteHost(hostname: string): void {
        let index = this.hosts.findIndex(x => x.host == hostname);
        if (index < 0) {
            this.hosts.push(this.resolveHost(hostname, null));
        }
    }

    /** Removes a remote host */
    removeRemoteHost(host: string, port: number): void {
        let index = this.hosts.findIndex(x => x.ip == host && x.port == port);
        if (index >= 0) {
            this.hosts.splice(index, 1);
        }
    }

    /** Connects to the server */
    connect(): void {

        if (this.hosts.length == 0) {
            throw 'There is no host to connect. Please add a remote host with addRemoteHost function';
        }

        if (this._currentHostIndex < 0) {
            this._currentHostIndex++;
        }

        if (this._currentHostIndex >= this.hosts.length) {
            this._currentHostIndex = 0;
        }

        this.host = this.hosts[this._currentHostIndex];
        this._autoReconnectDisabled = false;
        this._currentHostIndex++;
        this.createConnection();
    }

    /** Disconnects from the server */
    disconnect(): void {
        if (this._socket) {
            this._autoReconnectDisabled = true;
            this._socket.destroy();
            this._socket = null;
        }
    }

    private checkReconnect(): void {
        if (this.autoReconnect && !this._autoReconnectDisabled) {
            setTimeout(() => {
                if (this._status == HorseClientStatus.Disconnected) {
                    this._onlog.next('Reconnecting');
                    this.connect();
                }
            }, this.autoReconnectDelay);
        }
    }

    private createConnection() {

        this._lastMessageDate = new Date().getTime();
        this._protocolMessageReceived = false;
        this._status = HorseClientStatus.Connecting;

        this._reader.clear();
        this._socket = new net.Socket();
        this._socket.setNoDelay(true);

        this._socket.connect({ host: this.host.ip, port: this.host.port },
            () => {
                this._socket.write(new Uint8Array(PredefinedMessages.getProtocolBuffer()));

                let infoMessage = new HorseMessage();
                infoMessage.type = MessageType.Server;
                infoMessage.contentType = KnownContentTypes.Hello;

                infoMessage.addStringLine('NONE /');
                infoMessage.addStringLine(HorseHeaders.CLIENT_ID + ':' + this.clientId);

                if (this.clientName) {
                    infoMessage.addStringLine(HorseHeaders.CLIENT_NAME + ':' + this.clientName);
                }

                if (this.clientType) {
                    infoMessage.addStringLine(HorseHeaders.CLIENT_TYPE + ':' + this.clientType);
                }

                if (this.clientToken) {
                    infoMessage.addStringLine(HorseHeaders.CLIENT_TOKEN + ':' + this.clientToken);
                }

                this.properties.forEach(prop => {
                    infoMessage.addStringLine(prop.key + ':' + prop.value);
                })

                this.send(infoMessage, false);

                this._status = HorseClientStatus.Connected;
                this._onconnected.next(this);
                this._onlog.next('Connected to ' + this.host.ip + ':' + this.host.port);
            });

        this._socket.on('data', (data) => {

            if (!this._protocolMessageReceived) {

                if (data.length < 8) {
                    this._onlog.next('Invalid Protocol: ' + data);
                    this.disconnect();
                }
                else if (data.length == 8) {
                    if (data.toString('utf-8') == 'HORSE/30') {
                        this._protocolMessageReceived = true;
                    }
                    else {
                        this._onlog.next('Invalid Protocol: ' + data);
                        this.disconnect();
                    }
                }
                else if (data.length > 8) {
                    let protocolData = Buffer.allocUnsafe(8);
                    data.copy(protocolData, 0, 0, 8);

                    if (protocolData.toString('utf-8') == 'HORSE/30') {
                        this._protocolMessageReceived = true;
                        let nextData = Buffer.allocUnsafe(data.length - 8);
                        data.copy(nextData, 0, 8);
                        this._reader.read(nextData);
                    }
                    else {
                        this._onlog.next('Invalid Protocol: ' + protocolData);
                        this.disconnect();
                    }
                }
            }
            else {
                this._reader.read(data);
            }
        });

        this._socket.on('close', () => {
            this._reader.clear();
            this._onlog.next('Connection Closed');
            this._status = HorseClientStatus.Disconnected;
            this._ondisconnected.next(this);
            this.checkReconnect();
        });

        this._socket.on('error', err => {
            this._onlog.next('Connection Error: ' + err);
        });

        this._socket.on('timeout', () => {
            this._onlog.next('Connection Timeout');
        });
    }

    private processReceivedMessage(message: HorseMessage): void {

        this._lastMessageDate = new Date().getTime();

        switch (message.type) {

            case MessageType.Ping:
                this._socket.write(PredefinedMessages.getPongBuffer());
                break;

            case MessageType.Server:
                if (message.contentType == KnownContentTypes.Accepted) {
                    this.clientId = message.target;
                }

                if (message.contentType == KnownContentTypes.Found) {

                    let mainHost = message.findHeaderValue(HorseHeaders.NODE_PUBLIC_HOST);
                    let successorHost = message.findHeaderValue(HorseHeaders.SUCCESSOR_NODE);

                    if (successorHost && !this.hosts.find(x => x.host == successorHost)) {
                        this.hosts.push(this.resolveHost(successorHost, 'successor'));
                    }

                    if (mainHost && !this.hosts.find(x => x.host == mainHost)) {
                        this.host = this.resolveHost(mainHost, 'main');
                        this.hosts.push(this.host);
                    }

                    this.disconnect();
                    this.connect();
                }

                if (message.contentType == KnownContentTypes.Accepted || message.contentType == KnownContentTypes.ResetContent) {
                    this.refreshRemoteHosts(message);
                }

                break;

            case MessageType.Response:

                let obs = this._observers.get(message.messageId);
                if (obs) {
                    obs.subject.next(HorseResult.success(message));
                    obs.subject.complete();
                    obs.released = true;
                    this._observers.delete(obs.id);
                }

                break;

            case MessageType.Terminate:
                this.disconnect();
                break;
        }
    }


    private refreshRemoteHosts(message: HorseMessage): void {

        let successorHost = message.findHeaderValue(HorseHeaders.SUCCESSOR_NODE);
        let replaceNodes = message.findHeaderValue(HorseHeaders.REPLICA_NODE);

        if (replaceNodes) {
            let replicaHosts = replaceNodes.split(',');
            replicaHosts.forEach(replicaHost => {
                if (replicaHost) {
                    let found = this.hosts.find(x => x.host == replicaHost);
                    if (!found) {
                        this.hosts.push(this.resolveHost(replicaHost, 'replica'));
                    }
                }
            })
        }

        if (successorHost) {

            let successorIndex = this.hosts.findIndex(x => x.host == successorHost);
            if (successorIndex >= 0) {
                this.hosts.splice(successorIndex, 1);
            }

            this.hosts.unshift(this.resolveHost(successorHost, 'successor'));
        }

        let mainIndex = this.hosts.findIndex(x => x.type == 'main');
        if (mainIndex > 0) {
            let mainHost = this.hosts[mainIndex];
            this.hosts.splice(mainIndex, 1);
            this.hosts.unshift(mainHost);
        }

        this._currentHostIndex = -1;
    }


    /** Sends a message to the server */
    send(message: HorseMessage, waitForResponse: boolean = false, additionalHeaders: MessageHeader[] = null): Observable<HorseResult> {

        message.waitResponse = waitForResponse;
        let observer: MessageObserver = {
            id: message.messageId,
            released: false,
            subject: new Subject<HorseResult>()
        };

        if (waitForResponse) {

            if (!message.messageId) {
                message.setId(this.generateUniqueId());
                observer.id = message.messageId;
            }

            this._observers.set(message.messageId, observer);

            of(observer)
                .pipe(
                    delay(this.messageTimeout),
                    take(1),
                    filter(o => !o.released)
                )
                .subscribe(obs => {
                    this._observers.delete(obs.id);
                    if (!obs.subject.closed) {
                        obs.subject.next(HorseResult.create(HorseResultCode.RequestTimeout, 'Message Timeout'));
                        obs.subject.complete();
                    }
                });
        }

        let buffer = this._writer.write(message, additionalHeaders);
        let array = new Uint8Array(buffer);

        this._socket.write(array, undefined, err => {
            if (waitForResponse) {
                this._observers.delete(observer.id);
                observer.released = true;
            }

            if (!observer.subject.closed) {
                observer.subject.next(HorseResult.create(HorseResultCode.SendError, err?.message));
                observer.subject.complete();
            }
        });

        return observer.subject.pipe(take(1));
    }

    /** Sends acknowledge message of the original message */
    sendAcknowledge(original: HorseMessage, positive: boolean = true, negativeReason?: string): Observable<HorseResult> {

        if (!original.messageId)
            throw 'The message does not have an ID. Acknowledge message cannot sent';

        let ack = original.createAcknowledge(positive, negativeReason);
        return this.send(ack);
    }

    private resolveHost(host: string, type: NodeType): RemoteHost {

        let i = host.indexOf('://');
        let protocol = host.substring(0, i).toLowerCase();
        let j = host.lastIndexOf(':');
        let ip = host.substring(i + 3, j).replace(/\//g, '');
        let port = host.substring(j + 1).replace(/\//g, '');

        if (protocol != 'horses' && protocol != 'horse') {
            throw 'Invalid protocol for ' + host;
        }

        let result: RemoteHost = {
            host: host,
            ip: ip,
            port: parseInt(port),
            type: type,
            sll: protocol == 'horses'
        };

        return result;
    }
}